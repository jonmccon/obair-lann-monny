<!doctype html>
<html lang="{{ metadata.language }}">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>{{ title or metadata.title }}</title>
		<meta name="description" content="{{ description or metadata.description }}">

		{#- Atom and JSON feeds included by default #}
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="{{ metadata.title }}">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="{{ metadata.title }}">

		{#- Uncomment this if youâ€™d like folks to know that you used Eleventy to build your site!  #}
		<meta name="generator" content="{{ eleventy.generator }}">

		{#-
		CSS bundles are provided via the `eleventy-plugin-bundle` plugin:
		1. You can add to them using `{% css %}`
		2. You can get from them using `{% getBundle "css" %}` or `{% getBundleFileUrl "css" %}`
		3. You can do the same for JS: {% js %}{% endjs %} and <script>{% getBundle "js" %}</script>
		4. Learn more: https://github.com/11ty/eleventy-plugin-bundle
		#}

		{#- Add an arbitrary string to the bundle #}
		{# {%- css %}* { box-sizing: border-box; }{% endcss %} #}
		{#- Add the contents of a file to the bundle #}
		{%- css %}{% include "public/css/index.css" %}{% endcss %}
		{#- Or add from node_modules #}
		{# {%- css %}{% include "node_modules/prismjs/themes/prism-okaidia.css" %}{% endcss %} #}

		{#- Render the CSS bundle using Inlined CSS (for the fastest site performance in production) #}
		<style>{% getBundle "css" %}</style>
		{#- Renders the CSS bundle using a separate file, if you can't set CSP directive style-src: 'unsafe-inline' #}
		{#- <link rel="stylesheet" href="{% getBundleFileUrl "css" %}"> #}

		{#- Image lightbox CSS #}
		<style>
		/* Lightbox overlay */
		.lightbox-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.9);
			z-index: 1000;
			cursor: pointer;
		}
		
		.lightbox-overlay.active {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		.lightbox-image {
			max-width: 90%;
			max-height: 90%;
			object-fit: contain;
			cursor: default;
		}
		
		.lightbox-close {
			position: absolute;
			top: 20px;
			right: 30px;
			color: white;
			font-size: 40px;
			font-weight: bold;
			cursor: pointer;
			z-index: 1001;
		}
		
		.lightbox-close:hover {
			color: #ccc;
		}
		
		/* Style for lightbox-enabled images */
		.lightbox-trigger {
			cursor: zoom-in;
			transition: opacity 0.3s ease;
		}
		
		.lightbox-trigger:hover {
			opacity: 0.8;
		}
		</style>

		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-173P35S0MG"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());

			gtag('config', 'G-173P35S0MG');
		</script>
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header>
			<a href="/" class="home-link">{{ metadata.title }}</a>

			{#- Read more about `eleventy-navigation` at https://www.11ty.dev/docs/plugins/navigation/ #}
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
				{%- for entry in collections.all | eleventyNavigation %}
					<li class="nav-item"><a href="{{ entry.url }}"{% if entry.url == page.url %} aria-current="page"{% endif %}>{{ entry.title }}</a></li>
				{%- endfor %}
				</ul>
			</nav>
		</header>

		<main id="skip">
			{{ content | safe }}
		</main>

		<footer></footer>

		<!-- Image lightbox HTML structure -->
		<div class="lightbox-overlay" id="lightbox">
			<span class="lightbox-close" id="lightbox-close">&times;</span>
			<img class="lightbox-image" id="lightbox-img" src="" alt="">
		</div>

		<!-- Image lightbox JavaScript -->
		<script>
		document.addEventListener('DOMContentLoaded', function() {
			const lightbox = document.getElementById('lightbox');
			const lightboxImg = document.getElementById('lightbox-img');
			const lightboxClose = document.getElementById('lightbox-close');
			
			// Add click handlers to all lightbox trigger images
			document.querySelectorAll('.lightbox-trigger').forEach(function(img) {
				img.addEventListener('click', function(e) {
					e.preventDefault();
					lightboxImg.src = this.src;
					lightboxImg.alt = this.alt;
					lightbox.classList.add('active');
				});
			});
			
			// Close lightbox when clicking overlay or close button
			lightbox.addEventListener('click', function() {
				lightbox.classList.remove('active');
			});
			
			lightboxClose.addEventListener('click', function() {
				lightbox.classList.remove('active');
			});
			
			// Prevent closing when clicking the image itself
			lightboxImg.addEventListener('click', function(e) {
				e.stopPropagation();
			});
			
			// Close lightbox with Escape key
			document.addEventListener('keydown', function(e) {
				if (e.key === 'Escape' && lightbox.classList.contains('active')) {
					lightbox.classList.remove('active');
				}
			});

			// Enhanced Image Gallery Functionality
			const imageGrid = document.querySelector('.image-grid');
			if (imageGrid) {
				// Check if this is a touch device
				const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
				
				// Lazy loading for gallery images
				const lazyImages = imageGrid.querySelectorAll('img');
				
				// Performance: Use Intersection Observer for lazy loading
				if ('IntersectionObserver' in window) {
					const imageObserver = new IntersectionObserver((entries, observer) => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								const img = entry.target;
								// Add performance hint for faster loading
								img.loading = 'eager';
								img.decoding = 'async';
								// Cache images in browser
								if (img.dataset.src) {
									img.src = img.dataset.src;
									img.removeAttribute('data-src');
								}
								observer.unobserve(img);
							}
						});
					}, {
						rootMargin: '100px' // Start loading 100px before image comes into view
					});

					lazyImages.forEach(img => imageObserver.observe(img));
				}

				// Gallery control slider for touch devices
				if (isTouchDevice) {
					const imageItems = imageGrid.querySelectorAll('.image-item');
					const totalImages = imageItems.length;
					const galleryImages = imageGrid.querySelectorAll('img');
					
					// Function to create and setup slider
					function createSliderControl() {
						// Create slider control
						const sliderContainer = document.createElement('div');
						sliderContainer.className = 'gallery-slider-container';
						sliderContainer.innerHTML = `
							<input type="range" 
								   class="gallery-slider" 
								   min="0" 
								   max="${totalImages - 1}" 
								   value="0" 
								   step="1">
							<div class="slider-label">Drag to preview images</div>
						`;
						
						// Insert slider after the gallery
						imageGrid.parentNode.insertBefore(sliderContainer, imageGrid.nextSibling);
						
						const slider = sliderContainer.querySelector('.gallery-slider');
						let currentSelectedIndex = -1; // Track currently selected item
						let rafId = null; // Request animation frame ID
						
						// Optimized slider update function
						function updateGallerySelection(selectedIndex) {
							// Cancel any pending animation frame
							if (rafId) {
								cancelAnimationFrame(rafId);
							}
							
							rafId = requestAnimationFrame(() => {
								// Only update if selection actually changed
								if (currentSelectedIndex !== selectedIndex) {
									// Remove class from previously selected item only
									if (currentSelectedIndex >= 0 && imageItems[currentSelectedIndex]) {
										imageItems[currentSelectedIndex].classList.remove('gallery-selected');
									}
									
									// Add class to newly selected item
									if (imageItems[selectedIndex]) {
										imageItems[selectedIndex].classList.add('gallery-selected');
										currentSelectedIndex = selectedIndex;
									}
								}
								rafId = null;
							});
						}
						
						// Use throttled input handler for smooth performance
						let throttleTimeout = null;
						slider.addEventListener('input', function(e) {
							const selectedIndex = parseInt(e.target.value);
							
							// Clear existing throttle
							if (throttleTimeout) {
								clearTimeout(throttleTimeout);
							}
							
							// Throttle to 60fps for smooth performance
							throttleTimeout = setTimeout(() => {
								updateGallerySelection(selectedIndex);
							}, 16); // ~60fps
						});
						
						// Also handle change event for final position
						slider.addEventListener('change', function(e) {
							const selectedIndex = parseInt(e.target.value);
							updateGallerySelection(selectedIndex);
						});
					}
					
					// Wait for all gallery images to load before creating slider
					let loadedImages = 0;
					const totalGalleryImages = galleryImages.length;
					
					function checkAllImagesLoaded() {
						loadedImages++;
						if (loadedImages === totalGalleryImages) {
							// Small delay to ensure everything is rendered
							setTimeout(createSliderControl, 100);
						}
					}
					
					// Check if images are already loaded or set up load listeners
					galleryImages.forEach(img => {
						if (img.complete && img.naturalHeight !== 0) {
							// Image already loaded
							checkAllImagesLoaded();
						} else {
							// Image still loading
							img.addEventListener('load', checkAllImagesLoaded);
							img.addEventListener('error', checkAllImagesLoaded); // Handle errors gracefully
						}
					});
					
					// Fallback: create slider after 2 seconds if images still haven't loaded
					setTimeout(() => {
						if (loadedImages < totalGalleryImages) {
							createSliderControl();
						}
					}, 2000);
				}

				// Cache management for performance
				// Store scroll position for back navigation
				if ('sessionStorage' in window) {
					// Restore scroll position on page load
					const savedScrollPos = sessionStorage.getItem('galleryScrollPos');
					if (savedScrollPos) {
						imageGrid.scrollLeft = parseInt(savedScrollPos, 10);
					}

					// Save scroll position when navigating away
					window.addEventListener('beforeunload', function() {
						sessionStorage.setItem('galleryScrollPos', imageGrid.scrollLeft);
					});
				}
			}
		});
		</script>

		<!-- This page `{{ page.url | htmlBaseUrl }}` was built on {% currentBuildDate %} -->
	</body>
</html>
