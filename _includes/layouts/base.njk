<!doctype html>
<html lang="{{ metadata.language }}">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>{{ title or metadata.title }}</title>
		<meta name="description" content="{{ description or metadata.description }}">

		{#- Atom and JSON feeds included by default #}
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="{{ metadata.title }}">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="{{ metadata.title }}">

		{#- Uncomment this if youâ€™d like folks to know that you used Eleventy to build your site!  #}
		<meta name="generator" content="{{ eleventy.generator }}">

		{#-
		CSS bundles are provided via the `eleventy-plugin-bundle` plugin:
		1. You can add to them using `{% css %}`
		2. You can get from them using `{% getBundle "css" %}` or `{% getBundleFileUrl "css" %}`
		3. You can do the same for JS: {% js %}{% endjs %} and <script>{% getBundle "js" %}</script>
		4. Learn more: https://github.com/11ty/eleventy-plugin-bundle
		#}

		{#- Add an arbitrary string to the bundle #}
		{# {%- css %}* { box-sizing: border-box; }{% endcss %} #}
		{#- Add the contents of a file to the bundle #}
		{%- css %}{% include "public/css/index.css" %}{% endcss %}
		{#- Or add from node_modules #}
		{# {%- css %}{% include "node_modules/prismjs/themes/prism-okaidia.css" %}{% endcss %} #}

		{#- Render the CSS bundle using Inlined CSS (for the fastest site performance in production) #}
		<style>{% getBundle "css" %}</style>
		{#- Renders the CSS bundle using a separate file, if you can't set CSP directive style-src: 'unsafe-inline' #}
		{#- <link rel="stylesheet" href="{% getBundleFileUrl "css" %}"> #}

		{#- Image lightbox CSS #}
		<style>
		/* Lightbox overlay */
		.lightbox-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.9);
			z-index: 1000;
			cursor: pointer;
		}
		
		.lightbox-overlay.active {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		.lightbox-image {
			max-width: 90%;
			max-height: 90%;
			object-fit: contain;
			cursor: default;
		}
		
		.lightbox-close {
			position: absolute;
			top: 20px;
			right: 30px;
			color: white;
			font-size: 40px;
			font-weight: bold;
			cursor: pointer;
			z-index: 1001;
		}
		
		.lightbox-close:hover {
			color: #ccc;
		}
		
		/* Style for lightbox-enabled images */
		.lightbox-trigger {
			cursor: zoom-in;
			transition: opacity 0.3s ease;
		}
		
		.lightbox-trigger:hover {
			opacity: 0.8;
		}
		</style>

		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-173P35S0MG"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());

			gtag('config', 'G-173P35S0MG');
		</script>
	</head>
	<body>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<header>
			<a href="/" class="home-link">{{ metadata.title }}</a>

			{#- Read more about `eleventy-navigation` at https://www.11ty.dev/docs/plugins/navigation/ #}
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				<ul class="nav">
				{%- for entry in collections.all | eleventyNavigation %}
					<li class="nav-item"><a href="{{ entry.url }}"{% if entry.url == page.url %} aria-current="page"{% endif %}>{{ entry.title }}</a></li>
				{%- endfor %}
				</ul>
			</nav>
		</header>

		<main id="skip">
			{{ content | safe }}
		</main>

		<footer></footer>

		<!-- Image lightbox HTML structure -->
		<div class="lightbox-overlay" id="lightbox">
			<span class="lightbox-close" id="lightbox-close">&times;</span>
			<img class="lightbox-image" id="lightbox-img" src="" alt="">
		</div>

		<!-- Image lightbox JavaScript -->
		<script>
		document.addEventListener('DOMContentLoaded', function() {
			const lightbox = document.getElementById('lightbox');
			const lightboxImg = document.getElementById('lightbox-img');
			const lightboxClose = document.getElementById('lightbox-close');
			
			// Add click handlers to all lightbox trigger images
			document.querySelectorAll('.lightbox-trigger').forEach(function(img) {
				img.addEventListener('click', function(e) {
					e.preventDefault();
					lightboxImg.src = this.src;
					lightboxImg.alt = this.alt;
					lightbox.classList.add('active');
				});
			});
			
			// Close lightbox when clicking overlay or close button
			lightbox.addEventListener('click', function() {
				lightbox.classList.remove('active');
			});
			
			lightboxClose.addEventListener('click', function() {
				lightbox.classList.remove('active');
			});
			
			// Prevent closing when clicking the image itself
			lightboxImg.addEventListener('click', function(e) {
				e.stopPropagation();
			});
			
			// Close lightbox with Escape key
			document.addEventListener('keydown', function(e) {
				if (e.key === 'Escape' && lightbox.classList.contains('active')) {
					lightbox.classList.remove('active');
				}
			});

			// Enhanced Image Gallery Functionality
			const imageGrid = document.querySelector('.image-grid');
			if (imageGrid) {
				// Check if this is a touch device
				const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
				const isDesktop = window.matchMedia('(hover: hover) and (pointer: fine)').matches;
				
				// Add console logging for debugging
				console.log('Touch interactions enabled:', {
					isTouchDevice,
					isDesktop,
					hasGallery: true
				});

				// Lazy loading for gallery images
				const lazyImages = imageGrid.querySelectorAll('img');
				
				// Performance: Use Intersection Observer for lazy loading
				if ('IntersectionObserver' in window) {
					const imageObserver = new IntersectionObserver((entries, observer) => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								const img = entry.target;
								// Add performance hint for faster loading
								img.loading = 'eager';
								img.decoding = 'async';
								// Cache images in browser
								if (img.dataset.src) {
									img.src = img.dataset.src;
									img.removeAttribute('data-src');
								}
								observer.unobserve(img);
							}
						});
					}, {
						rootMargin: '100px' // Start loading 100px before image comes into view
					});

					lazyImages.forEach(img => imageObserver.observe(img));
				}

				// Touch and Mouse interaction handling
				let startX = 0;
				let startY = 0;
				let isDragging = false;
				let hasScrolled = false;
				const SCROLL_THRESHOLD = 10; // px threshold for distinguishing tap vs swipe

				// Touch event handlers
				imageGrid.addEventListener('touchstart', function(e) {
					startX = e.touches[0].clientX;
					startY = e.touches[0].clientY;
					isDragging = false;
					hasScrolled = false;
					
					// Visual feedback for touch start
					const imageItem = e.target.closest('.image-item');
					if (imageItem) {
						imageItem.classList.add('touch-feedback');
						console.log('Touch started on image item');
					}
				}, { passive: true });

				imageGrid.addEventListener('touchmove', function(e) {
					if (!startX || !startY) return;
					
					const currentX = e.touches[0].clientX;
					const currentY = e.touches[0].clientY;
					const diffX = Math.abs(currentX - startX);
					const diffY = Math.abs(currentY - startY);

					// Detect horizontal scrolling (scrubbing)
					if (diffX > SCROLL_THRESHOLD || diffY > SCROLL_THRESHOLD) {
						isDragging = true;
						hasScrolled = true;
						console.log('Touch scrubbing detected:', { diffX, diffY });
						
						// Remove touch feedback during scrubbing
						const touchFeedbackItems = imageGrid.querySelectorAll('.touch-feedback');
						touchFeedbackItems.forEach(item => item.classList.remove('touch-feedback'));
						
						// Allow native horizontal scrolling for scrubbing
						if (diffX > diffY) {
							// Horizontal scroll - prevent vertical scroll
							e.preventDefault();
						}
					}
				}, { passive: false });

				imageGrid.addEventListener('touchend', function(e) {
					// Remove visual feedback
					const touchFeedbackItems = imageGrid.querySelectorAll('.touch-feedback');
					touchFeedbackItems.forEach(item => item.classList.remove('touch-feedback'));
					
					console.log('Touch ended:', { hasScrolled, isDragging });
					
					// Reset values
					startX = 0;
					startY = 0;
					isDragging = false;
					
					// Small delay to ensure scroll state is captured
					setTimeout(() => {
						hasScrolled = false;
					}, 50);
				}, { passive: true });

				// Enhanced click/tap handling for navigation
				imageGrid.addEventListener('click', function(e) {
					const imageItem = e.target.closest('.image-item');
					const link = imageItem?.querySelector('a');
					
					console.log('Click detected:', { hasScrolled, isDragging, hasLink: !!link });
					
					if (link && !hasScrolled && !isDragging) {
						// Only navigate if it was a genuine tap/click, not a scroll/drag
						console.log('Navigating to:', link.href);
						window.location.href = link.href;
					}
				});

				// Prevent default link behavior to handle it manually
				const galleryLinks = imageGrid.querySelectorAll('.image-item a');
				galleryLinks.forEach(link => {
					link.addEventListener('click', function(e) {
						e.preventDefault(); // We handle navigation manually above
					});
				});

				// Desktop simulation for testing (shows touch interactions on desktop)
				if (isDesktop && !isTouchDevice) {
					// Add visual indicator for desktop users about touch interactions
					const touchInfo = document.createElement('div');
					touchInfo.innerHTML = `
						<p style="font-size: 0.8em; color: #666; margin: 0.5em 0;">
							ðŸ’¡ <strong>Touch interactions available:</strong> On touch devices, you can scroll horizontally through images without accidentally navigating to projects.
						</p>
					`;
					touchInfo.style.cssText = 'margin: 1em 0; padding: 0.5em; background: #f5f5f5; border-radius: 4px; font-family: -apple-system, system-ui, sans-serif;';
					
					// Insert info after the gallery
					imageGrid.parentNode.insertBefore(touchInfo, imageGrid.nextSibling);
					
					// Desktop simulation: Show touch feedback on mouse events for demonstration
					const imageItems = imageGrid.querySelectorAll('.image-item');
					imageItems.forEach(item => {
						item.addEventListener('mousedown', function(e) {
							// Simulate touch feedback on desktop
							this.classList.add('touch-feedback');
							console.log('Desktop touch simulation: mousedown');
						});
						
						item.addEventListener('mouseup', function(e) {
							// Remove touch feedback
							setTimeout(() => {
								this.classList.remove('touch-feedback');
							}, 100);
							console.log('Desktop touch simulation: mouseup');
						});
						
						item.addEventListener('mouseleave', function(e) {
							// Clean up if mouse leaves during press
							this.classList.remove('touch-feedback');
						});
					});
				}

				// Cache management for performance
				// Store scroll position for back navigation
				if ('sessionStorage' in window) {
					// Restore scroll position on page load
					const savedScrollPos = sessionStorage.getItem('galleryScrollPos');
					if (savedScrollPos) {
						imageGrid.scrollLeft = parseInt(savedScrollPos, 10);
						console.log('Restored scroll position:', savedScrollPos);
					}

					// Save scroll position when navigating away
					window.addEventListener('beforeunload', function() {
						sessionStorage.setItem('galleryScrollPos', imageGrid.scrollLeft);
						console.log('Saved scroll position:', imageGrid.scrollLeft);
					});
				}
			}
		});
		</script>

		<!-- This page `{{ page.url | htmlBaseUrl }}` was built on {% currentBuildDate %} -->
	</body>
</html>
