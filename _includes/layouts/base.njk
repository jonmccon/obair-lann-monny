<!doctype html>
<html lang="{{ metadata.language }}">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>{{ title or metadata.title }}</title>
		<meta name="description" content="{{ description or metadata.description }}">

		{#- Atom and JSON feeds included by default #}
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="{{ metadata.title }}">
		<link rel="alternate" href="/feed/feed.json" type="application/json" title="{{ metadata.title }}">

		{#- Uncomment this if youâ€™d like folks to know that you used Eleventy to build your site!  #}
		<meta name="generator" content="{{ eleventy.generator }}">

		{#-
		CSS bundles are provided via the `eleventy-plugin-bundle` plugin:
		1. You can add to them using `{% css %}`
		2. You can get from them using `{% getBundle "css" %}` or `{% getBundleFileUrl "css" %}`
		3. You can do the same for JS: {% js %}{% endjs %} and <script>{% getBundle "js" %}</script>
		4. Learn more: https://github.com/11ty/eleventy-plugin-bundle
		#}

		{#- Add an arbitrary string to the bundle #}
		{# {%- css %}* { box-sizing: border-box; }{% endcss %} #}
		{#- Add the contents of a file to the bundle #}
		{%- css %}{% include "public/css/index.css" %}{% endcss %}
		{#- Or add from node_modules #}
		{# {%- css %}{% include "node_modules/prismjs/themes/prism-okaidia.css" %}{% endcss %} #}

		{#- Render the CSS bundle using Inlined CSS (for the fastest site performance in production) #}
		<style>{% getBundle "css" %}</style>
		{#- Renders the CSS bundle using a separate file, if you can't set CSP directive style-src: 'unsafe-inline' #}
		{#- <link rel="stylesheet" href="{% getBundleFileUrl "css" %}"> #}

		{#- Image lightbox CSS #}
		<style>
		/* Lightbox overlay */
		.lightbox-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.9);
			z-index: 1000;
			cursor: pointer;
		}
		
		.lightbox-overlay.active {
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		.lightbox-image {
			max-width: 90%;
			max-height: 90%;
			object-fit: contain;
			cursor: default;
		}
		
		.lightbox-close {
			position: absolute;
			top: 20px;
			right: 30px;
			color: white;
			font-size: 40px;
			font-weight: bold;
			cursor: pointer;
			z-index: 1001;
		}
		
		.lightbox-close:hover {
			color: #ccc;
		}
		
		/* Style for lightbox-enabled images */
		.lightbox-trigger {
			cursor: zoom-in;
			transition: opacity 0.3s ease;
		}
		
		.lightbox-trigger:hover {
			opacity: 0.8;
		}
		</style>

		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-173P35S0MG"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag(){dataLayer.push(arguments);}
			gtag('js', new Date());

			gtag('config', 'G-173P35S0MG');
		</script>
	</head>
	<body{% if layout == "layouts/post.njk" %} class="post-page{% if not images or images.length == 0 %} no-hero-image{% endif %}"{% endif %}>
		<a href="#skip" class="visually-hidden">Skip to main content</a>

		<div class="site-wrapper">
		<header>
			{#- Read more about `eleventy-navigation` at https://www.11ty.dev/docs/plugins/navigation/ #}
			<nav>
				<h2 class="visually-hidden">Top level navigation menu</h2>
				{#- Organize navigation into two lines as requested -#}
				<div class="nav-line-1">
					<ul class="nav">
					{%- for entry in collections.all | eleventyNavigation %}
						{%- if entry.order <= 2 %}
							<li class="nav-item"><a href="{{ entry.url }}"{% if entry.url == page.url %} aria-current="page"{% endif %}>{{ entry.title }}</a></li>
						{%- endif %}
					{%- endfor %}
					</ul>
				</div>
				<div class="nav-line-2">
					<ul class="nav">
					{%- for entry in collections.all | eleventyNavigation %}
						{%- if entry.order > 2 %}
							<li class="nav-item"><a href="{{ entry.url }}"{% if entry.url == page.url %} aria-current="page"{% endif %}>{{ entry.title }}</a></li>
						{%- endif %}
					{%- endfor %}
					</ul>
				</div>
			</nav>
		</header>

		<main id="skip">
			{{ content | safe }}
		</main>
		</div>

		<footer></footer>

		<!-- Image lightbox HTML structure -->
		<div class="lightbox-overlay" id="lightbox">
			<span class="lightbox-close" id="lightbox-close">&times;</span>
			<img class="lightbox-image" id="lightbox-img" src="" alt="">
		</div>

		<!-- Image lightbox JavaScript -->
		<script>
		document.addEventListener('DOMContentLoaded', function() {
			const lightbox = document.getElementById('lightbox');
			const lightboxImg = document.getElementById('lightbox-img');
			const lightboxClose = document.getElementById('lightbox-close');
			
			// Add click handlers to all lightbox trigger images
			document.querySelectorAll('.lightbox-trigger').forEach(function(img) {
				img.addEventListener('click', function(e) {
					e.preventDefault();
					lightboxImg.src = this.src;
					lightboxImg.alt = this.alt;
					lightbox.classList.add('active');
				});
			});
			
			// Close lightbox when clicking overlay or close button
			lightbox.addEventListener('click', function() {
				lightbox.classList.remove('active');
			});
			
			lightboxClose.addEventListener('click', function() {
				lightbox.classList.remove('active');
			});
			
			// Prevent closing when clicking the image itself
			lightboxImg.addEventListener('click', function(e) {
				e.stopPropagation();
			});
			
			// Close lightbox with Escape key
			document.addEventListener('keydown', function(e) {
				if (e.key === 'Escape' && lightbox.classList.contains('active')) {
					lightbox.classList.remove('active');
				}
			});

			// Enhanced Image Gallery Functionality with aggressive performance optimization
			const imageGrid = document.querySelector('.image-grid');
			if (imageGrid) {
				// Performance monitoring to prevent black screen issues
				let performanceIssueDetected = false;
				const performanceThreshold = 100; // ms threshold for animation lag
				
				// Monitor performance and adjust accordingly
				function monitorPerformance() {
					const startTime = performance.now();
					requestAnimationFrame(() => {
						const endTime = performance.now();
						const frameDuration = endTime - startTime;
						
						if (frameDuration > performanceThreshold) {
							performanceIssueDetected = true;
							// Reduce animation complexity
							document.documentElement.style.setProperty('--reduced-animations', '1');
						}
					});
				}
				
				// Start performance monitoring
				monitorPerformance();
				// Comprehensive touch device detection
				// More aggressive detection to catch tablets requesting desktop sites
				const isTouchDevice = (() => {
					// Primary: Check for touch points (most reliable for modern devices)
					if (navigator.maxTouchPoints > 0) return true;
					
					// Secondary: Legacy touch detection
					if ('ontouchstart' in window) return true;
					
					// Tertiary: Check for touch-specific APIs
					if ('ontouchend' in window || 'ontouchmove' in window) return true;
					
					// Quaternary: CSS media query checks
					if (window.matchMedia) {
						// Check for coarse pointer (touch)
						if (window.matchMedia('(pointer: coarse)').matches) return true;
						
						// Check for hover capability - tablets often report 'none'
						if (window.matchMedia('(hover: none)').matches) return true;
						
						// Check for any-pointer: coarse (covers secondary touch inputs)
						if (window.matchMedia('(any-pointer: coarse)').matches) return true;
						
						// Check for any-hover: none (tablets requesting desktop often match this)
						if (window.matchMedia('(any-hover: none)').matches) return true;
					}
					
					// User agent detection for common tablet/mobile patterns
					const userAgent = navigator.userAgent.toLowerCase();
					const touchDevicePatterns = [
						'android', 'iphone', 'ipad', 'ipod', 'blackberry', 
						'windows phone', 'touch', 'mobile', 'tablet'
					];
					if (touchDevicePatterns.some(pattern => userAgent.includes(pattern))) return true;
					
					// Screen size checks - more comprehensive than before
					const screenWidth = Math.max(window.innerWidth, screen.width);
					const screenHeight = Math.max(window.innerHeight, screen.height);
					
					// Portrait tablets and phones
					if (screenWidth <= 768) return true;
					
					// Landscape tablets (common resolutions)
					if (screenWidth <= 1024 && screenHeight <= 768) return true;
					
					// Check for high DPI screens which are often touch devices
					if (window.devicePixelRatio && window.devicePixelRatio > 1.5) {
						// High DPI devices under certain size thresholds are likely touch
						if (screenWidth <= 1366 || screenHeight <= 1024) return true;
					}
					
					// As a final safeguard, err on the side of showing the slider
					// Better to have a slider on a non-touch device than missing it on touch
					return false;
				})();
				
				// Aggressive performance optimizations for image loading
				const lazyImages = imageGrid.querySelectorAll('img');
				
				// Critical: Preload first few images immediately for instant interaction
				const preloadCount = Math.min(3, lazyImages.length);
				lazyImages.forEach((img, index) => {
					if (index < preloadCount) {
						// Eagerly load first few images
						img.loading = 'eager';
						img.decoding = 'async';
						// Add performance hints
						const link = document.createElement('link');
						link.rel = 'preload';
						link.as = 'image';
						link.href = img.src;
						document.head.appendChild(link);
					} else {
						// Lazy load remaining images
						img.loading = 'lazy';
						img.decoding = 'async';
					}
				});
				
				// Enhanced Intersection Observer for aggressive loading
				if ('IntersectionObserver' in window) {
					const imageObserver = new IntersectionObserver((entries, observer) => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								const img = entry.target;
								// Aggressive loading hints
								img.loading = 'eager';
								img.decoding = 'async';
								
								// Cache images in browser with fetchpriority hint
								if (img.dataset.src) {
									img.src = img.dataset.src;
									img.removeAttribute('data-src');
								}
								
								// Add fetch priority for visible images
								img.fetchPriority = 'high';
								observer.unobserve(img);
							}
						});
					}, {
						rootMargin: '200px', // More aggressive preloading - start 200px before visible
						threshold: 0.1
					});

					lazyImages.forEach(img => imageObserver.observe(img));
				}

				// Gallery control slider for touch devices
				if (isTouchDevice) {
					const imageItems = imageGrid.querySelectorAll('.image-item');
					const totalImages = imageItems.length;
					const galleryImages = imageGrid.querySelectorAll('img');
					let sliderCreated = false; // Prevent double creation
					
					// Function to create and setup slider
					function createSliderControl() {
						// Prevent double creation
						if (sliderCreated) return;
						sliderCreated = true;
						
						// Create slider control
						const sliderContainer = document.createElement('div');
						sliderContainer.className = 'gallery-slider-container';
						sliderContainer.innerHTML = `
							<input type="range" 
								   class="gallery-slider gallery-slider-disabled" 
								   min="0" 
								   max="${totalImages - 1}" 
								   value="0" 
								   step="1"
								   disabled>
							<div class="slider-label">Loading images...</div>
						`;
						
						// Insert slider after the gallery
						imageGrid.parentNode.insertBefore(sliderContainer, imageGrid.nextSibling);
						
						const slider = sliderContainer.querySelector('.gallery-slider');
						const sliderLabel = sliderContainer.querySelector('.slider-label');
						let currentSelectedIndex = -1; // Track currently selected item
						let rafId = null; // Request animation frame ID
						
						// Function to enable slider when images are ready
						function enableSlider() {
							slider.disabled = false;
							slider.classList.remove('gallery-slider-disabled');
							sliderLabel.textContent = 'Drag to preview images';
						}
						
						// Store reference for later enabling
						window.gallerySliderControl = { slider, enableSlider };
						
						// Highly optimized slider update function
						function updateGallerySelection(selectedIndex) {
							// Use immediate scheduling for smoother performance
							if (rafId) {
								cancelAnimationFrame(rafId);
							}
							
							// Batch DOM updates for better performance
							rafId = requestAnimationFrame(() => {
								// Only update if selection actually changed
								if (currentSelectedIndex !== selectedIndex) {
									// Batch remove/add operations
									const batch = document.createDocumentFragment();
									
									// Remove class from previously selected item
									if (currentSelectedIndex >= 0 && imageItems[currentSelectedIndex]) {
										imageItems[currentSelectedIndex].classList.remove('gallery-selected');
									}
									
									// Add class to newly selected item with performance hints
									if (imageItems[selectedIndex]) {
										const selectedItem = imageItems[selectedIndex];
										selectedItem.classList.add('gallery-selected');
										
										// Hint browser about upcoming animation
										selectedItem.style.willChange = 'transform, width';
										
										// Remove will-change after animation completes
										setTimeout(() => {
											selectedItem.style.willChange = 'auto';
										}, 200);
										
										currentSelectedIndex = selectedIndex;
									}
								}
								rafId = null;
							});
						}
						
						// Aggressive optimization: Use passive event listeners and debouncing
						let throttleTimeout = null;
						let isAnimating = false;
						
						// Passive event listener for better scroll performance
						slider.addEventListener('input', function(e) {
							if (slider.disabled || isAnimating) return;
							
							const selectedIndex = parseInt(e.target.value);
							
							// Clear existing throttle
							if (throttleTimeout) {
								clearTimeout(throttleTimeout);
							}
							
							// Optimized throttling - adjust to device capabilities
							const throttleDelay = window.devicePixelRatio > 2 ? 20 : 16; // Slower on high-DPI
							throttleTimeout = setTimeout(() => {
								isAnimating = true;
								updateGallerySelection(selectedIndex);
								
								// Reset animation flag after transition
								setTimeout(() => {
									isAnimating = false;
								}, 200);
							}, throttleDelay);
						}, { passive: true });
						
						// Immediate response on final position for better UX
						slider.addEventListener('change', function(e) {
							if (slider.disabled) return;
							
							const selectedIndex = parseInt(e.target.value);
							// Clear any pending throttled updates
							if (throttleTimeout) {
								clearTimeout(throttleTimeout);
								throttleTimeout = null;
							}
							updateGallerySelection(selectedIndex);
						}, { passive: true });
					}
					
					// Create slider immediately in disabled state
					createSliderControl();
					
					// Track image loading to enable slider when ready
					let loadedImages = 0;
					const totalGalleryImages = galleryImages.length;
					
					function checkAllImagesLoaded() {
						loadedImages++;
						if (loadedImages === totalGalleryImages && window.gallerySliderControl) {
							// Small delay to ensure everything is rendered
							setTimeout(() => {
								window.gallerySliderControl.enableSlider();
							}, 100);
						}
					}
					
					// Check if images are already loaded or set up load listeners
					galleryImages.forEach(img => {
						if (img.complete && img.naturalHeight !== 0) {
							// Image already loaded
							checkAllImagesLoaded();
						} else {
							// Image still loading
							img.addEventListener('load', checkAllImagesLoaded);
							img.addEventListener('error', checkAllImagesLoaded); // Handle errors gracefully
						}
					});
					
					// Fallback: enable slider after 2 seconds if images still haven't loaded
					setTimeout(() => {
						if (loadedImages < totalGalleryImages && window.gallerySliderControl) {
							window.gallerySliderControl.enableSlider();
						}
					}, 2000);
				} else {
					// Mouse-based desktop device - optimized hover functionality
					const imageItems = imageGrid.querySelectorAll('.image-item');
					let currentHoveredIndex = -1;
					let hoverRafId = null;
					
					// Optimized function to update gallery selection on hover
					function updateGalleryHover(hoveredIndex) {
						if (hoverRafId) {
							cancelAnimationFrame(hoverRafId);
						}
						
						hoverRafId = requestAnimationFrame(() => {
							// Remove previous selection
							if (currentHoveredIndex >= 0 && imageItems[currentHoveredIndex]) {
								const prevItem = imageItems[currentHoveredIndex];
								prevItem.classList.remove('selected');
								prevItem.style.willChange = 'auto';
							}
							
							// Add new selection with performance hints
							if (hoveredIndex >= 0 && imageItems[hoveredIndex]) {
								const newItem = imageItems[hoveredIndex];
								newItem.style.willChange = 'transform, width';
								newItem.classList.add('selected');
								currentHoveredIndex = hoveredIndex;
								
								// Remove will-change after animation
								setTimeout(() => {
									newItem.style.willChange = 'auto';
								}, 150);
							} else {
								currentHoveredIndex = -1;
							}
							hoverRafId = null;
						});
					}
					
					// Add optimized mouse hover listeners with debouncing
					imageItems.forEach((item, index) => {
						let enterTimeout = null;
						let leaveTimeout = null;
						
						item.addEventListener('mouseenter', () => {
							// Clear any pending leave timeout
							if (leaveTimeout) {
								clearTimeout(leaveTimeout);
								leaveTimeout = null;
							}
							
							// Slight delay to prevent excessive hovering
							enterTimeout = setTimeout(() => {
								updateGalleryHover(index);
							}, 50);
						}, { passive: true });
						
						item.addEventListener('mouseleave', () => {
							// Clear any pending enter timeout
							if (enterTimeout) {
								clearTimeout(enterTimeout);
								enterTimeout = null;
							}
							
							// Immediate response on leave for better UX
							updateGalleryHover(-1);
						}, { passive: true });
					});
				}

				// Cache management for performance
				// Store scroll position for back navigation
				if ('sessionStorage' in window) {
					// Restore scroll position on page load
					const savedScrollPos = sessionStorage.getItem('galleryScrollPos');
					if (savedScrollPos) {
						imageGrid.scrollLeft = parseInt(savedScrollPos, 10);
					}

					// Save scroll position when navigating away
					window.addEventListener('beforeunload', function() {
						sessionStorage.setItem('galleryScrollPos', imageGrid.scrollLeft);
					});
				}
			}
		});
		</script>

		<!-- This page `{{ page.url | htmlBaseUrl }}` was built on {% currentBuildDate %} -->
	</body>
</html>
